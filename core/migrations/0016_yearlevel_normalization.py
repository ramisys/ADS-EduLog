# Generated by Django 5.2.8 on 2025-01-01 00:00

from django.db import migrations, models
import django.db.models.deletion


def create_year_levels(apps, schema_editor):
    """Create initial year level records"""
    # Check if table exists first
    with schema_editor.connection.cursor() as cursor:
        cursor.execute("""
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name='core_yearlevel';
        """)
        table_exists = cursor.fetchone() is not None
    
    if not table_exists:
        return  # Table will be created by CreateModel operation
    
    YearLevel = apps.get_model('core', 'YearLevel')
    
    year_levels = [
        {'level': 1, 'name': '1st Year', 'order': 1, 'is_active': True},
        {'level': 2, 'name': '2nd Year', 'order': 2, 'is_active': True},
        {'level': 3, 'name': '3rd Year', 'order': 3, 'is_active': True},
        {'level': 4, 'name': '4th Year', 'order': 4, 'is_active': True},
    ]
    
    for yl_data in year_levels:
        YearLevel.objects.get_or_create(
            level=yl_data['level'],
            defaults=yl_data
        )


def migrate_classsection_year_levels(apps, schema_editor):
    """Migrate ClassSection to have year_level based on section name patterns"""
    ClassSection = apps.get_model('core', 'ClassSection')
    YearLevel = apps.get_model('core', 'YearLevel')
    
    # Get year levels
    year_level_map = {}
    for yl in YearLevel.objects.all():
        year_level_map[yl.level] = yl
    
    # Default to 1st Year if we can't determine
    default_year_level = year_level_map.get(1)
    
    for section in ClassSection.objects.all():
        # Try to extract year level from section name
        # Common patterns: BSIT1A, BSIT-1A, BSIT 1A, etc.
        import re
        section_name = section.name or ''
        
        # Extract first digit from section name
        match = re.search(r'(\d)', section_name)
        if match:
            year_num = int(match.group(1))
            if 1 <= year_num <= 4:
                section.year_level = year_level_map.get(year_num, default_year_level)
            else:
                section.year_level = default_year_level
        else:
            # No digit found, default to 1st Year
            section.year_level = default_year_level
        
        section.save()


def migrate_student_year_levels(apps, schema_editor):
    """Migrate StudentProfile year_level from CharField to ForeignKey using SQL"""
    YearLevel = apps.get_model('core', 'YearLevel')
    
    # Get year level IDs for SQL CASE statement
    year_levels = YearLevel.objects.all()
    first_year_id = YearLevel.objects.get(level=1).id
    
    # Build SQL CASE statement for year level mapping
    case_statements = []
    for yl in year_levels:
        # Map various text formats
        case_statements.append(f"WHEN LOWER(TRIM(_old_year_level)) = '{yl.name.lower()}' THEN {yl.id}")
        if yl.level == 1:
            case_statements.append(f"WHEN LOWER(TRIM(_old_year_level)) = '1st year' THEN {yl.id}")
        elif yl.level == 2:
            case_statements.append(f"WHEN LOWER(TRIM(_old_year_level)) = '2nd year' THEN {yl.id}")
        elif yl.level == 3:
            case_statements.append(f"WHEN LOWER(TRIM(_old_year_level)) = '3rd year' THEN {yl.id}")
        elif yl.level == 4:
            case_statements.append(f"WHEN LOWER(TRIM(_old_year_level)) = '4th year' THEN {yl.id}")
        case_statements.append(f"WHEN LOWER(TRIM(_old_year_level)) = '{yl.level}' THEN {yl.id}")
    
    case_sql = " OR ".join([f"LOWER(TRIM(_old_year_level)) = '{yl.name.lower()}'" for yl in year_levels])
    
    # Use a single SQL UPDATE with CASE statement and COALESCE
    sql = f"""
        UPDATE core_studentprofile
        SET year_level_fk_id = COALESCE(
            CASE
                {' '.join(case_statements)}
                ELSE NULL
            END,
            (SELECT year_level_id FROM core_classsection WHERE id = core_studentprofile.section_id),
            {first_year_id}
        )
        WHERE year_level_fk_id IS NULL;
    """
    
    # Execute SQL - bypass Django's debug SQL formatter by using raw database connection
    # The issue is Django tries to format SQL for debugging: sql % params
    # We'll use the underlying sqlite3 connection directly
    db = schema_editor.connection
    raw_db = db.connection  # Get underlying sqlite3 connection
    
    # Temporarily disable foreign key checks
    raw_db.execute("PRAGMA foreign_keys=OFF")
    try:
        # Execute SQL directly on raw connection - bypasses Django's debug wrapper
        clean_sql = ' '.join(sql.split())
        raw_db.execute(clean_sql)
        raw_db.commit()
    finally:
        raw_db.execute("PRAGMA foreign_keys=ON")


def reverse_migrate_student_year_levels(apps, schema_editor):
    """Reverse migration - convert ForeignKey back to CharField"""
    StudentProfile = apps.get_model('core', 'StudentProfile')
    
    for student in StudentProfile.objects.all():
        if student.year_level:
            # Store year level name in a temporary field
            # Note: This is a simplified reverse - actual reverse would need
            # to restore the CharField, which is complex
            pass


def drop_views(apps, schema_editor):
    """Drop database views that reference tables being altered"""
    with schema_editor.connection.cursor() as cursor:
        cursor.execute("DROP VIEW IF EXISTS vw_teacher_subject_stats;")
        cursor.execute("DROP VIEW IF EXISTS vw_student_performance;")
        cursor.execute("DROP VIEW IF EXISTS vw_attendance_summary;")


def recreate_views(apps, schema_editor):
    """Recreate database views after migration"""
    with schema_editor.connection.cursor() as cursor:
        # Recreate vw_teacher_subject_stats
        cursor.execute("""
            CREATE VIEW IF NOT EXISTS vw_teacher_subject_stats AS
            SELECT 
                tp.id AS teacher_id,
                tp.teacher_id,
                u.first_name || ' ' || u.last_name AS teacher_name,
                s.id AS subject_id,
                s.code AS subject_code,
                s.name AS subject_name,
                cs.name AS section_name,
                COUNT(DISTINCT sp.id) AS student_count,
                COUNT(DISTINCT g.id) AS grade_count,
                COALESCE(AVG(g.grade), 0) AS average_grade,
                COUNT(DISTINCT a.id) AS attendance_count,
                SUM(CASE WHEN a.status = 'present' THEN 1 ELSE 0 END) AS present_count,
                SUM(CASE WHEN a.status = 'absent' THEN 1 ELSE 0 END) AS absent_count
            FROM core_teacherprofile tp
            INNER JOIN core_user u ON tp.user_id = u.id
            INNER JOIN core_subject s ON tp.id = s.teacher_id
            INNER JOIN core_classsection cs ON s.section_id = cs.id
            LEFT JOIN core_studentprofile sp ON s.section_id = sp.section_id
            LEFT JOIN core_grade g ON s.id = g.subject_id AND sp.id = g.student_id
            LEFT JOIN core_attendance a ON s.id = a.subject_id AND sp.id = a.student_id
            GROUP BY tp.id, tp.teacher_id, u.first_name, u.last_name, s.id, s.code, s.name, cs.name;
        """)


def fix_orphaned_students(apps, schema_editor):
    """Fix students with invalid section references before migration"""
    # Use raw SQL to fix orphaned foreign keys - more reliable during migration
    with schema_editor.connection.cursor() as cursor:
        # Set section_id to NULL for students with invalid section references
        cursor.execute("""
            UPDATE core_studentprofile 
            SET section_id = NULL 
            WHERE section_id IS NOT NULL 
            AND section_id NOT IN (SELECT id FROM core_classsection);
        """)


def cleanup_temp_tables(apps, schema_editor):
    """Clean up any leftover temporary tables from failed migrations"""
    with schema_editor.connection.cursor() as cursor:
        # Get all tables
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' AND name LIKE 'new__%'")
        temp_tables = [row[0] for row in cursor.fetchall()]
        for table in temp_tables:
            cursor.execute(f"DROP TABLE IF EXISTS {table};")


def column_exists(schema_editor, table_name, column_name):
    """Check if a column exists in a table"""
    with schema_editor.connection.cursor() as cursor:
        cursor.execute(f"PRAGMA table_info({table_name})")
        columns = [row[1] for row in cursor.fetchall()]
        return column_name in columns


def add_field_if_not_exists(schema_editor, table_name, column_name, field_sql):
    """Add a field only if it doesn't already exist"""
    if not column_exists(schema_editor, table_name, column_name):
        with schema_editor.connection.cursor() as cursor:
            cursor.execute(f"ALTER TABLE {table_name} ADD COLUMN {field_sql}")


def add_classsection_year_level(apps, schema_editor):
    """Add year_level to ClassSection if it doesn't exist"""
    if not column_exists(schema_editor, 'core_classsection', 'year_level_id'):
        with schema_editor.connection.cursor() as cursor:
            cursor.execute("""
                ALTER TABLE core_classsection 
                ADD COLUMN year_level_id INTEGER REFERENCES core_yearlevel(id);
            """)


def add_studentprofile_old_year_level(apps, schema_editor):
    """Add _old_year_level to StudentProfile if it doesn't exist"""
    if not column_exists(schema_editor, 'core_studentprofile', '_old_year_level'):
        with schema_editor.connection.cursor() as cursor:
            cursor.execute("""
                ALTER TABLE core_studentprofile 
                ADD COLUMN _old_year_level VARCHAR(20);
            """)


def add_studentprofile_year_level_fk(apps, schema_editor):
    """Add year_level_fk to StudentProfile if it doesn't exist"""
    if not column_exists(schema_editor, 'core_studentprofile', 'year_level_fk_id'):
        with schema_editor.connection.cursor() as cursor:
            cursor.execute("""
                ALTER TABLE core_studentprofile 
                ADD COLUMN year_level_fk_id INTEGER REFERENCES core_yearlevel(id);
            """)


def remove_year_level_charfield_if_exists(apps, schema_editor):
    """Remove year_level CharField if it exists (idempotent)"""
    if column_exists(schema_editor, 'core_studentprofile', 'year_level'):
        # The actual removal will be handled by Django's RemoveField operation
        # This function just ensures we can proceed
        pass


def handle_year_level_migration(apps, schema_editor):
    """Handle year_level field migration - remove CharField and rename FK if needed"""
    has_char = column_exists(schema_editor, 'core_studentprofile', 'year_level')
    has_fk = column_exists(schema_editor, 'core_studentprofile', 'year_level_fk_id')
    has_final = column_exists(schema_editor, 'core_studentprofile', 'year_level_id')
    
    # If we're already in the final state, do nothing
    if has_final:
        return
    
    # If CharField exists, we'll let Django's RemoveField handle it
    # If year_level_fk_id exists, we'll let Django's RenameField handle it
    # This function just validates the state
    pass


def handle_year_level_rename(apps, schema_editor):
    """Handle year_level_fk_id to year_level_id migration - handles partial migration state"""
    has_fk = column_exists(schema_editor, 'core_studentprofile', 'year_level_fk_id')
    has_final = column_exists(schema_editor, 'core_studentprofile', 'year_level_id')
    
    if has_fk and has_final:
        # Both exist - copy data from fk to final where final is NULL
        with schema_editor.connection.cursor() as cursor:
            cursor.execute("""
                UPDATE core_studentprofile 
                SET year_level_id = year_level_fk_id 
                WHERE year_level_id IS NULL AND year_level_fk_id IS NOT NULL;
            """)
        # Note: We can't easily drop year_level_fk_id in SQLite without remaking the table
        # It will be ignored since year_level_id is the active column
    elif has_fk and not has_final:
        # Only fk exists - rename it
        with schema_editor.connection.cursor() as cursor:
            cursor.execute("ALTER TABLE core_studentprofile RENAME COLUMN year_level_fk_id TO year_level_id;")
    # If only final exists, we're done


class Migration(migrations.Migration):

    dependencies = [
        ('core', '0015_studentenrollment'),
    ]

    operations = [
        # Step 0: Drop views that reference tables being altered
        migrations.RunPython(drop_views, migrations.RunPython.noop),
        
        # Step 0.3: Clean up any leftover temporary tables
        migrations.RunPython(cleanup_temp_tables, migrations.RunPython.noop),
        
        # Step 0.5: Fix orphaned foreign keys before migration
        migrations.RunPython(fix_orphaned_students, migrations.RunPython.noop),
        
        # Step 1: Create YearLevel model (handle case where table might already exist)
        # First check if table exists, if not create it
        # Step 1: Create YearLevel model (idempotent - handles existing table)
        migrations.RunSQL(
            sql="""
                CREATE TABLE IF NOT EXISTS core_yearlevel (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    level INTEGER NOT NULL UNIQUE,
                    name VARCHAR(20) NOT NULL UNIQUE,
                    "order" INTEGER NOT NULL UNIQUE,
                    is_active BOOLEAN NOT NULL DEFAULT 1,
                    CHECK (level IN (1, 2, 3, 4))
                );
                CREATE INDEX IF NOT EXISTS core_yearle_level_idx ON core_yearlevel(level);
                CREATE INDEX IF NOT EXISTS core_yearle_is_acti_idx ON core_yearlevel(is_active, "order");
            """,
            reverse_sql="DROP TABLE IF EXISTS core_yearlevel;",
            state_operations=[
                migrations.CreateModel(
                    name='YearLevel',
                    fields=[
                        ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                        ('level', models.IntegerField(choices=[(1, '1st Year'), (2, '2nd Year'), (3, '3rd Year'), (4, '4th Year')], help_text='Academic year level (1-4)', unique=True)),
                        ('name', models.CharField(help_text="Display name (e.g., '1st Year')", max_length=20, unique=True)),
                        ('order', models.IntegerField(help_text='Ordering for display purposes', unique=True)),
                        ('is_active', models.BooleanField(default=True, help_text='Whether this year level is currently active')),
                    ],
                    options={
                        'verbose_name': 'Year Level',
                        'verbose_name_plural': 'Year Levels',
                        'ordering': ['order'],
                    },
                ),
                migrations.AddIndex(
                    model_name='yearlevel',
                    index=models.Index(fields=['level'], name='core_yearle_level_idx'),
                ),
                migrations.AddIndex(
                    model_name='yearlevel',
                    index=models.Index(fields=['is_active', 'order'], name='core_yearle_is_acti_idx'),
                ),
            ]
        ),
        
        # Step 2: Create year level records
        migrations.RunPython(create_year_levels, migrations.RunPython.noop),
        
        # Step 3: Add year_level to ClassSection (nullable first for data migration) - idempotent
        migrations.SeparateDatabaseAndState(
            database_operations=[
                migrations.RunPython(add_classsection_year_level, migrations.RunPython.noop),
            ],
            state_operations=[
                migrations.AddField(
                    model_name='classsection',
                    name='year_level',
                    field=models.ForeignKey(
                        help_text='Academic year level for this section',
                        null=True,
                        on_delete=django.db.models.deletion.PROTECT,
                        related_name='sections',
                        to='core.yearlevel'
                    ),
                ),
            ]
        ),
        
        # Step 4: Migrate ClassSection year levels
        migrations.RunPython(migrate_classsection_year_levels, migrations.RunPython.noop),
        
        # Step 5: Make year_level required in ClassSection
        migrations.AlterField(
            model_name='classsection',
            name='year_level',
            field=models.ForeignKey(
                help_text='Academic year level for this section',
                on_delete=django.db.models.deletion.PROTECT,
                related_name='sections',
                to='core.yearlevel'
            ),
        ),
        
        # Step 6: Add temporary field to store old year_level text for students - idempotent
        migrations.SeparateDatabaseAndState(
            database_operations=[
                migrations.RunPython(add_studentprofile_old_year_level, migrations.RunPython.noop),
            ],
            state_operations=[
                migrations.AddField(
                    model_name='studentprofile',
                    name='_old_year_level',
                    field=models.CharField(blank=True, max_length=20, null=True),
                ),
            ]
        ),
        
        # Step 7: Copy existing year_level CharField to temporary field (idempotent)
        migrations.RunPython(
            lambda apps, schema_editor: (
                schema_editor.connection.cursor().execute(
                    "UPDATE core_studentprofile SET _old_year_level = year_level WHERE _old_year_level IS NULL;"
                ) if column_exists(schema_editor, 'core_studentprofile', 'year_level') else None
            ),
            migrations.RunPython.noop,
        ),
        
        # Step 8: Add new year_level ForeignKey (nullable first) - idempotent
        migrations.SeparateDatabaseAndState(
            database_operations=[
                migrations.RunPython(add_studentprofile_year_level_fk, migrations.RunPython.noop),
            ],
            state_operations=[
                migrations.AddField(
                    model_name='studentprofile',
                    name='year_level_fk',
                    field=models.ForeignKey(
                        help_text='Academic year level of the student',
                        null=True,
                        on_delete=django.db.models.deletion.PROTECT,
                        related_name='students',
                        to='core.yearlevel'
                    ),
                ),
            ]
        ),
        
        # Step 9: Migrate student year levels
        migrations.RunPython(migrate_student_year_levels, reverse_migrate_student_year_levels),
        
        # Step 10: Drop indexes that reference year_level before removing the field - idempotent
        # Only drop from database; state will be updated when we recreate the index later
        migrations.RunSQL(
            sql="""
                DROP INDEX IF EXISTS core_student_section_year_idx;
                DROP INDEX IF EXISTS core_studen_section_7ed467_idx;
            """,
            reverse_sql=migrations.RunSQL.noop,
        ),
        
        # Step 10.5: Ensure all year_level_fk_id values are valid
        migrations.RunSQL(
            sql="""
                -- Set NULL values to first year
                UPDATE core_studentprofile 
                SET year_level_fk_id = (SELECT id FROM core_yearlevel WHERE level = 1 LIMIT 1)
                WHERE year_level_fk_id IS NULL;
                
                -- Fix any invalid foreign key references
                UPDATE core_studentprofile 
                SET year_level_fk_id = (SELECT id FROM core_yearlevel WHERE level = 1 LIMIT 1)
                WHERE year_level_fk_id NOT IN (SELECT id FROM core_yearlevel);
            """,
            reverse_sql=migrations.RunSQL.noop,
        ),
        
        # Step 11: Remove old CharField and rename new field (idempotent)
        # Check if year_level CharField exists - if not, skip RemoveField
        migrations.RunPython(
            lambda apps, schema_editor: (
                # Only update state if column exists in database
                # If it doesn't exist, we'll skip the RemoveField operation
            ),
            migrations.RunPython.noop,
        ),
        migrations.SeparateDatabaseAndState(
            database_operations=[
                # Skip database operation if column doesn't exist
                migrations.RunPython(
                    lambda apps, schema_editor: None,
                    migrations.RunPython.noop,
                ),
            ],
            state_operations=[
                # Only update state - database column may already be removed
                migrations.RemoveField(
                    model_name='studentprofile',
                    name='year_level',
                ),
            ]
        ),
        
        # Step 11.5: Handle year_level_fk_id to year_level_id migration
        migrations.RunPython(
            handle_year_level_rename,
            migrations.RunPython.noop,
        ),
        migrations.SeparateDatabaseAndState(
            database_operations=[],
            state_operations=[
                migrations.RenameField(
                    model_name='studentprofile',
                    old_name='year_level_fk',
                    new_name='year_level',
                ),
            ]
        ),
        
        # Step 11.6: Ensure all year_level_id values are valid before making it required
        migrations.RunSQL(
            sql="""
                -- Fix any invalid foreign key references
                UPDATE core_studentprofile 
                SET year_level_id = (SELECT id FROM core_yearlevel WHERE level = 1 LIMIT 1)
                WHERE year_level_id IS NULL 
                   OR year_level_id NOT IN (SELECT id FROM core_yearlevel);
            """,
            reverse_sql=migrations.RunSQL.noop,
        ),
        
        # Step 12: Make year_level required
        # Disable foreign keys during table remake
        migrations.RunSQL(
            sql="PRAGMA foreign_keys=OFF;",
            reverse_sql="PRAGMA foreign_keys=ON;",
        ),
        migrations.AlterField(
            model_name='studentprofile',
            name='year_level',
            field=models.ForeignKey(
                help_text='Academic year level of the student',
                on_delete=django.db.models.deletion.PROTECT,
                related_name='students',
                to='core.yearlevel'
            ),
        ),
        migrations.RunSQL(
            sql="PRAGMA foreign_keys=ON;",
            reverse_sql="PRAGMA foreign_keys=OFF;",
        ),
        
        # Step 13: Remove temporary field
        migrations.RemoveField(
            model_name='studentprofile',
            name='_old_year_level',
        ),
        
        # Step 14: Update indexes
        migrations.AlterIndexTogether(
            name='studentprofile',
            index_together=set(),
        ),
        migrations.AddIndex(
            model_name='studentprofile',
            index=models.Index(fields=['year_level'], name='core_studen_year_le_idx'),
        ),
        migrations.AddIndex(
            model_name='studentprofile',
            index=models.Index(fields=['year_level', 'section'], name='core_studen_year_le_idx2'),
        ),
        # Recreate the section+year_level index that was dropped earlier
        migrations.AddIndex(
            model_name='studentprofile',
            index=models.Index(fields=['section', 'year_level'], name='core_student_section_year_idx'),
        ),
        migrations.AddIndex(
            model_name='classsection',
            index=models.Index(fields=['year_level'], name='core_classs_year_le_idx'),
        ),
        migrations.AddIndex(
            model_name='classsection',
            index=models.Index(fields=['year_level', 'name'], name='core_classs_year_le_idx2'),
        ),
        
        # Step 14: Recreate database views
        migrations.RunPython(recreate_views, drop_views),
    ]

